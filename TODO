- сделать, чтобы можно было Debug пускать через syslog (да ещё и на другую машину)

- (IONotifyController): Разработать механизм заказа переодических уведомлений (msec), независимо от того, менялись ли датчики..
- (IONotifyController): Разработать механизм заказа группы датчиков сразу (и ответ тоже группой)

- циклическое хранилище для аварийных следов на основе SQLite
- сделать MultiChannelSlave (слушает несколько каналов, но в SM сохраняет данные
только от одного, при пропаже связи переключается на другой и т.д. по кругу)

// --- Оптимизация.. --- //
   - "продумать" функцию key()... может наложить ограничение на диапазон id..

- uniset-codegen:  сделать в src.xml <description> и генерировать на его основе описание класса (нужно ли)
- uniset-codegen: дописать функцию help со всеми параметрами для _SK, тесты
- uniset-codegen: добавить в генерируемую документацию значения по умолчанию..
- uniset-codegen: добавить возможность переопределять привязку из командной строки
- uniset-codegen: добавить ключ --gen-sensor-name для генерирования name_Item.. (чтобы можно было в логах использовать текстовые названия)
- uniset-codegen: перенести инициализацию полей в header (c++11) и "разгрузить конструкторы"

- unetudp: добавить возможность привязать номера текущего посылаемого и принимаемого пакетов к датчику

- встроить различные сигналы (sigc).. в ModbusExchange и другие классы..
- ModbusMaster: встроить возможность задать 'pulsar' (регистр сердцебиения)

- ТЕСТЫ! ТЕСТЫ! ТЕСТЫ!

- Перевести взаимодействие PassiveObject <--> ProxyManager на shared_ptr (или weak_ptr). // нужно ли

- Сделать диапазонные пороги в IOBase и SM  (т.е. "1" когда min >= val <= max ).

SQL:
====
- добавить  работу с History (при передаче указателя на SM в конструкторе).

Debug:
- дописать в codegen документацию по запуску и управлению логами через LogServer

LogServer:
- подумать насчёт буфера для хранения последних n-сообщений (с возможностью вытащить через REST API)

Modbus:
- разобраться с big/little endian (вместо SWAP_SHORT)

HTTP API:
- список объектов возвращать с их типом (чтобы можно было SM вычислять)
- Сделать возможность настраивать параметры httpserver-а из командной строки (количество потоков и т.п.)
- ТЕСТЫ (как вариант поизучать про тестовые фреймворки на питоне (pytest?)
- Запрос у процесса обмена (MBSlave,MBxxMaster,UNet и т.п.) получение списка опрашиваемых датчиков
(датчиков с которыми ведётся работа данным процессом обмена)


- smonit запись значений в файл (csv?,sqlite?,gnuplot)
- python: gui sensor monitor 

IOBase: 
- возможность задавать свою формулу преобразования входного сигнала (помимо калибровки)..
- реализовать фильтр Калмана

- переписать систему инициализации и работы между UniSetActivator,UniSetManager и UniSetObject-ами (уменьшить количество функций (связность))

- Использовать PIMPL (подумать.. это серьёзная переделка кода)

- совместимость между 64bit и 32bit - для этого нужно отказаться от использования сырого long и перейти либо на int32_t либо CORBA::Long.
Либо стоит всё-таки ввести свой тип данных value_t для хранимых значений, чтобы спокойно работать в x86_64 и x86_32
при этом скрыв детали реализации. А возможно в последствии наложить какие-то ограничения на этот тип

ModbusSlave: подумать насчёт оптимизации по скорости (вместо поиска по RegMap, сделать массив на 65535 регистров или map-ов по номеру функции,
всего 65kB памяти).

libev:
- переписать UNetUDP (на подумать)
- UniSetActivator (обработка сигналов и возможно вынести сюда DefaultEventLoop) (на подумать)

SM: подумать насчёт асинхронности публикации событий и посылки уведомления (setValue/push) через очередь..
// worker-ы рассылающие сообщения, очередь заданий, конфигурирование количества worker-ов, основной поток ждёт если нет свободных.

SM: Подумать насчёт применения https://github.com/efficient/libcuckoo


DB: Сделать регулируемый буфер на INSERT-ы БД, чтобы поберечь винт (DBServer_PGSQL, DBServer_MySQL...) // по времени или по количеству

в ThreadCreator использовать std::function()..


Разобраться с BigEndian и LittleEndian! Использовать htons,htol и т.п. (и реализации для 64bit)


timeout_t перевести всё на chrono.. чтобы использовать setTimeout( 2msec );

ВОЗМОЖНО СТОИТ:
Уйти от использования libxml2,DebugLog ==> и применять всё из libpoco (http://pocoproject.org/documentation/index.html)
или всё-таки на boost?

ИДЕИ
-----
- NoSQL база (в памяти) как буфер (держит интенсивную запись) перед "не спешной" записью в реляционную (MySQL,Postgre и т.п.)


==================

lock-free: mentomic, libcds


version 3
=========
- подумать нужен ли нам где-то ZeroMQ (zerorpc) (вместо omniORB?)
- (или) подумать может стоит перейти на использование ICE вместо CORBA (libIce не собирается под aarch!)

Перепроектировать классы [ObjectRepository, UInterface, ORepHelpers] с целью выработки абстрактного интерфейса
UResolver (или ObjectRepository) позволяющего манипулировать CORBA-ссылками на объекты, но по возможности 
скрывающими детали "CORBA-кухни". Чтобы можно было "хранилище" реализовать на базе СУБД, SQLite, файлов и т.п.
Примерно интерфейс должен уметь следующее:
- resgister(name)
- unregister(name)
- resolve(name)
- resolve(name,node) // обращение к IResolver удалённого узла..
- create(rootname)

- Перепроектировать OIndex и Configure.. Инициализировать для Configure(объектом OIndex)

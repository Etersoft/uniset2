
// Метод с использованием заказа датчиков
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
/*
 DO NOT EDIT THIS FILE. IT IS AUTOGENERATED FILE.
 ALL YOUR CHANGES WILL BE LOST.

 НЕ РЕДАКТИРУЙТЕ ЭТОТ ФАЙЛ. ЭТОТ ФАЙЛ СОЗДАН АВТОМАТИЧЕСКИ.
 ВСЕ ВАШИ ИЗМЕНЕНИЯ БУДУТ ПОТЕРЯНЫ.
*/
// --------------------------------------------------------------------------
// generate timestamp: 2020-12-15+03:00
// -----------------------------------------------------------------------------
#include <memory>
#include <iomanip>
#include "Configuration.h"
#include "Exceptions.h"
#include "ORepHelpers.h"
#include "LogServer.h"
#include "DebugStream.h"
#include "LogAgregator.h"
#include "UObject_SK.h"

// -----------------------------------------------------------------------------
using namespace std;
using namespace uniset;
// -----------------------------------------------------------------------------

// --------------------------------------------------------------------------

// -----------------------------------------------------------------------------
UObject_SK::UObject_SK():
    // Инициализация идентификаторов (имена берутся из конф. файла)

    // Используемые идентификаторы сообщений (имена берутся из конф. файла)

    // variables (public and proteced)

    // ------------------
    active(false),

    idHeartBeat(DefaultObjectId),
    maxHeartBeat(10),
    confnode(0),
    smReadyTimeout(0),
    activated(false),
    askPause(2000),
    forceOut(false),
    // private variables

    end_private(false)
{
    mycrit << "UObject: init failed!!!!!!!!!!!!!!!" << endl;
    throw uniset::Exception( std::string(myname + ": init failed!!!") );
}
// -----------------------------------------------------------------------------
// ( val, confval, globalval, default val )
static const std::string init4_str( const std::string& s1, const std::string& s2,
                                    const std::string& s3, const std::string& s4 )
{
    if( !s1.empty() )
        return s1;

    if( !s2.empty() )
        return s2;

    if( !s3.empty() )
        return s3;

    return s4;
}
// -----------------------------------------------------------------------------
// ( val, confval, default val )
static const std::string init3_str( const std::string& s1, const std::string& s2, const std::string& s3 )
{
    if( !s1.empty() )
        return s1;

    if( !s2.empty() )
        return s2;

    return s3;
}
// -----------------------------------------------------------------------------
static uniset::ObjectId init_node( xmlNode* cnode, const std::string& prop )
{
    if( prop.empty() )
        return uniset_conf()->getLocalNode();

    auto conf = uniset_conf();

    if( conf->getProp(cnode, prop).empty() )
        return conf->getLocalNode();

    return conf->getNodeID(conf->getProp(cnode, prop));
}
// -----------------------------------------------------------------------------
UObject_SK::UObject_SK( ObjectId id, xmlNode* cnode, const std::string& _argprefix, xmlNode* globalnode ):
    UniSetObject(id),
    // Инициализация идентификаторов (имена берутся из конф. файла)

    // Используемые идентификаторы сообщений (имена берутся из конф. файла)

    // variables

    sleep_msec(150),
    active(true),
    argprefix( (_argprefix.empty() ? myname + "-" : _argprefix) ),

    idHeartBeat(DefaultObjectId),
    maxHeartBeat(10),
    confnode(cnode),
    smReadyTimeout(0),
    activated(false),
    askPause(uniset_conf()->getPIntProp(cnode, "askPause", 2000)),
    forceOut(false),

    end_private(false)
{
    auto conf = uniset_conf();


    if( uniset::findArgParam("--print-id-list", uniset_conf()->getArgc(), uniset_conf()->getArgv()) != -1 )
    {

        //      abort();
    }


    if( getId() == DefaultObjectId )
    {
        ostringstream err;
        err << "(UObject::init): Unknown ObjectID!";
        throw uniset::SystemError( err.str() );
    }

    mylog = make_shared<DebugStream>();
    mylog->setLogName(myname);
    {
        ostringstream s;
        s << argprefix << "log";
        conf->initLogStream(mylog, s.str());
    }

    loga = make_shared<LogAgregator>(myname + "-loga");
    loga->add(mylog);
    loga->add(ulog());

    logserv = make_shared<LogServer>(loga);
    logserv->init( argprefix + "logserver", confnode );



    UniXML::iterator it(cnode);

    // ------- init logserver ---
    if( findArgParam("--" + argprefix + "run-logserver", conf->getArgc(), conf->getArgv()) != -1 )
    {
        logserv_host = conf->getArg2Param("--" + argprefix + "logserver-host", it.getProp("logserverHost"), "localhost");
        logserv_port = conf->getArgPInt("--" + argprefix + "logserver-port", it.getProp("logserverPort"), getId());
    }

    forceOut = conf->getArgPInt("--" + argprefix + "force-out", it.getProp("forceOut"), false);

    string heart = conf->getArgParam("--" + argprefix + "heartbeat-id", it.getProp("heartbeat_id"));

    if( !heart.empty() )
    {
        idHeartBeat = conf->getSensorID(heart);

        if( idHeartBeat == DefaultObjectId )
        {
            ostringstream err;
            err << myname << ": не найден идентификатор для датчика 'HeartBeat' " << heart;
            throw uniset::SystemError(err.str());
        }

        int heartbeatTime = conf->getArgPInt("--" + argprefix + "heartbeat-time", it.getProp("heartbeatTime"), conf->getHeartBeatTime());

        if( heartbeatTime > 0 )
            ptHeartBeat.setTiming(heartbeatTime);
        else
            ptHeartBeat.setTiming(UniSetTimer::WaitUpTime);

        maxHeartBeat = conf->getArgPInt("--" + argprefix + "heartbeat-max", it.getProp("heartbeat_max"), 10);
    }

    // Инициализация значений


    si.id = uniset::DefaultObjectId;
    si.node = conf->getLocalNode();

    sleep_msec = conf->getArgPInt("--" + argprefix + "sleep-msec", "150", 150);

    string s_resetTime("");

    if( s_resetTime.empty() ) // -V547
        s_resetTime = "500";

    resetMsgTime = uni_atoi(init4_str(conf->getArgParam("--" + argprefix + "resetMsgTime"), conf->getProp(cnode, "resetMsgTime"), conf->getProp(globalnode, "resetMsgTime"), s_resetTime));
    ptResetMsg.setTiming(resetMsgTime);

    int sm_tout = conf->getArgInt("--" + argprefix + "sm-ready-timeout", "");

    if( sm_tout == 0 )
        smReadyTimeout = conf->getNCReadyTimeout();
    else if( sm_tout < 0 )
        smReadyTimeout = UniSetTimer::WaitUpTime;
    else
        smReadyTimeout = sm_tout;

    smTestID = conf->getSensorID(init4_str(conf->getArgParam("--" + argprefix + "sm-test-id"), conf->getProp(cnode, "smTestID"), conf->getProp(globalnode, "smTestID"), ""));


    if( smTestID == DefaultObjectId ) // -V547
        smTestID = getSMTestID();

    activateTimeout = conf->getArgPInt("--" + argprefix + "activate-timeout", 120000);

    int msec = conf->getArgPInt("--" + argprefix + "startup-timeout", conf->getStartupIgnoreTimeout());
    ptStartUpTimeout.setTiming(msec);

    // ===================== <variables> =====================

    // ===================== end of <variables> =====================

    vmonit(sleep_msec);
    vmonit(resetMsgTime);
    vmonit(forceOut);
    vmonit(argprefix);
    vmonit(idHeartBeat);
    vmonit(maxHeartBeat);
    vmonit(activateTimeout);
    vmonit(smReadyTimeout);
    vmonit(smTestID);


    // help надо выводить в конце, когда уже все переменные инициализированы по умолчанию
    if( uniset::findArgParam("--" + argprefix + "help", uniset_conf()->getArgc(), uniset_conf()->getArgv()) != -1 )
        cout << help() << endl;
}

// -----------------------------------------------------------------------------

UObject_SK::~UObject_SK()
{
}
// -----------------------------------------------------------------------------
void UObject_SK::updateValues()
{
    // Опрашиваем все входы...

}
// -----------------------------------------------------------------------------
void UObject_SK::updatePreviousValues() noexcept
{

}
// -----------------------------------------------------------------------------
void UObject_SK::checkSensors()
{

}
// -----------------------------------------------------------------------------
bool UObject_SK::setMsg( uniset::ObjectId _code, bool _state ) noexcept
{
    if( _code == uniset::DefaultObjectId )
    {
        mylog8 << myname << "(setMsg): попытка послать сообщение с DefaultObjectId" << endl;
        return false;
    }

    mylog8 << myname << "(setMsg): " << ( _state ? "SEND " : "RESET " ) << endl;

    // взводим автоматический сброс
    if( _state )
    {
        ptResetMsg.reset();
        trResetMsg.hi(false);
    }



    mylog8 << myname << "(setMsg): not found MessgeOID?!!" << endl;
    return false;
}
// -----------------------------------------------------------------------------
void UObject_SK::resetMsg()
{
    mylog8 << myname << "(resetMsg): reset messages.." << endl;
    // reset messages

}
// -----------------------------------------------------------------------------
uniset::ObjectId UObject_SK::getSMTestID() const
{
    if( smTestID != DefaultObjectId )
        return smTestID;



    return DefaultObjectId;
}
// -----------------------------------------------------------------------------
void UObject_SK::testMode( bool _state )
{
    if( !_state  )
        return;

    // отключаем все выходы

}
// -----------------------------------------------------------------------------

#ifndef DISABLE_REST_API
Poco::JSON::Object::Ptr UObject_SK::httpDumpIO()
{
    Poco::JSON::Object::Ptr jdata = new Poco::JSON::Object();

    Poco::JSON::Object::Ptr j_in = uniset::json::make_child(jdata, "in");



    Poco::JSON::Object::Ptr j_out = uniset::json::make_child(jdata, "out");



    return jdata;
}
// ----------------------------------------------------------------------------
#endif


std::string  UObject_SK::dumpIO()
{
    ostringstream s;
    s << myname << ": " << endl;

    std::list<std::string> v_in;
    ostringstream s1;


    std::list<std::string> v_out;


    s << endl;

    int n = 0;

    for( const auto& e : v_in )
    {
        s << e;

        if( (n++) % 2 )
            s << std::endl;
    }

    s << endl;
    n = 0;

    for( const auto& e : v_out )
    {
        s << e;

        if( (n++) % 2 )
            s << std::endl;
    }

    return s.str();
}
// ----------------------------------------------------------------------------
std::string  UObject_SK::msgstr( uniset::ObjectId id, bool showLinkName ) const
{
    ostringstream s;

    return "";
}
// ----------------------------------------------------------------------------
std::string  UObject_SK::str( uniset::ObjectId id, bool showLinkName ) const
{
    ostringstream s;

    return "";
}
// ----------------------------------------------------------------------------
std::string  UObject_SK::strval( uniset::ObjectId id, bool showLinkName ) const
{
    if( id == DefaultObjectId )
        return "";

    ostringstream s;

    return "";
}
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------
void UObject_SK::init_dlog( std::shared_ptr<DebugStream> d ) noexcept
{
    UObject_SK::mylog = d;
}
// ------------------------------------------------------------------------------------------
void UObject_SK::processingMessage( const uniset::VoidMessage* _msg )
{
    try
    {

        msgTypeStat[_msg->type] += 1;

        switch( _msg->type )
        {
            case Message::SensorInfo:
            {
                const SensorMessage* sm = reinterpret_cast<const SensorMessage*>(_msg);

                smStat[sm->id] += 1;

                preSensorInfo(sm);
            }
            break;

            case Message::Timer:
                preTimerInfo( reinterpret_cast<const TimerMessage*>(_msg) );
                break;

            case Message::SysCommand:
                preSysCommand( reinterpret_cast<const SystemMessage*>(_msg) );
                break;

            default:
                UniSetObject::processingMessage(_msg);
                break;
        }
    }
    catch( const std::exception& ex )
    {

        processingMessageCatchCount++;

        mycrit  << myname << "(processingMessage): " << ex.what() << endl;
    }
}
// -----------------------------------------------------------------------------
void UObject_SK::preSysCommand( const SystemMessage* _sm )
{
    switch( _sm->command )
    {
        case SystemMessage::WatchDog:
            myinfo << myname << "(preSysCommand): WatchDog" << endl;

            if( !active || !ptStartUpTimeout.checkTime() )
            {
                mywarn << myname << "(preSysCommand): игнорируем WatchDog, потому-что только-что стартанули" << endl;
                break;
            }

        case SystemMessage::StartUp:
        {
            ostate = "StartUp...";

            try
            {
                if( !logserv_host.empty() && logserv_port != 0 && !logserv->isRunning() )
                {
                    ostate = "StartUp: run log server...";
                    myinfo << myname << "(preSysCommand): run log server " << logserv_host << ":" << logserv_port << endl;
                    logserv->async_run(logserv_host, logserv_port);
                }
            }
            catch( std::exception& ex )
            {
                mywarn << myname << "(preSysCommand): CAN`t run log server err: " << ex.what() << endl;
            }
            catch( ... )
            {
                mywarn << myname << "(preSysCommand): CAN`t run log server err: catch ..." << endl;
            }

            ostate = "StartUp: wait sm ready..";

            if( !waitSM(smReadyTimeout) )
            {
                if( !cancelled )
                    uterminate();

                return;
            }

            ptStartUpTimeout.reset();
            // т.к. для io-переменных важно соблюдать последовательность!
            // сперва обновить входы..
            ostate = "StartUp: update values..";
            updateValues();
            ostate = "StartUp: init from SM..";
            initFromSM(); // потом обновить значения переменных, помеченных как инициализируемые из SM
            ostate = "StartUp: update outputs..";
            updateOutputs(true); // а потом уже выходы (принудительное обновление)
            ostate = "StartUp: pre ask sensors..";
            preAskSensors(UniversalIO::UIONotify);
            ostate = "StartUp: ask sensors..";
            askSensors(UniversalIO::UIONotify);
            active = true;
            ostate = "StartUp: [OK]";
            break;
        }

        case SystemMessage::FoldUp:
        case SystemMessage::Finish:
            preAskSensors(UniversalIO::UIODontNotify);
            askSensors(UniversalIO::UIODontNotify);
            break;

        case SystemMessage::LogRotate:
        {
            // переоткрываем логи
            mylogany << myname << "(preSysCommand): logRotate" << endl;
            string fname( log()->getLogFile() );

            if( !fname.empty() )
            {

                mylog->logFile(fname.c_str(), false);

                mylogany << myname << "(preSysCommand): ***************** mylog LOG ROTATE *****************" << endl;
            }

            if( logserv && !logserv_host.empty() && logserv_port != 0 )
            {
                try
                {
                    mylogany << myname << "(preSysCommand): try restart logserver.." << endl;
                    logserv->check(true);
                }
                catch( std::exception& ex )
                {
                    mywarn << myname << "(preSysCommand): CAN`t restart log server err: " << ex.what() << endl;
                }
                catch( ... )
                {
                    mywarn << myname << "(preSysCommand): CAN`t restart log server err: catch ..." << endl;
                }
            }
        }
        break;

        default:
            break;
    }

    sysCommand(_sm);
}
// -----------------------------------------------------------------------------

uniset::SimpleInfo* UObject_SK::getInfo( const char* userparam )
{
    uniset::SimpleInfo_var i = UniSetObject::getInfo(userparam);

    ostringstream inf;

    inf << i->info << endl;
    inf << "process state: " << ostate << endl;

    if( logserv /* && userparam < 0 */ )
    {
        inf << "LogServer: " << logserv_host << ":" << logserv_port
            << ( logserv->isRunning() ? "   [RUNNIG]" : "   [STOPPED]" ) << endl;

        inf << "         " << logserv->getShortInfo() << endl;
    }
    else
        inf << "LogServer: NONE" << endl;



    inf << "statistics: " << endl
        << "  processingMessageCatchCount: " << processingMessageCatchCount << endl;
    inf << "  Type of messages: " << endl;

    for( const auto& s : msgTypeStat )
        inf << "    (" << s.first << ")" << setw(10)  << getTypeOfMessage(s.first) << ": " << setw(5) << s.second << endl;

    inf << endl;


    inf << dumpIO() << endl;
    inf << endl;
    auto timers = getTimersList();
    inf << "Timers[" << timers.size() << "]:" << endl;

    for( const auto& t : timers )
    {
        inf << "  " << setw(15) << getTimerName(t.id) << "[" << t.id  << "]: msec="
            << setw(6) << t.tmr.getInterval()
            << "    timeleft="  << setw(6) << t.curTimeMS
            << "    tick="  << setw(3) << ( t.curTick >= 0 ? t.curTick : -1 )
            << endl;
    }

    inf << endl;
    inf << vmon.pretty_str() << endl;
    inf << endl;
    inf << getMonitInfo() << endl;

    i->info =  inf.str().c_str();

    return i._retn();
}
// -----------------------------------------------------------------------------

#ifndef DISABLE_REST_API
Poco::JSON::Object::Ptr UObject_SK::httpGet( const Poco::URI::QueryParameters& params )
{
    Poco::JSON::Object::Ptr json = UniSetObject::httpGet(params);

    Poco::JSON::Object::Ptr jdata = json->getObject(myname);

    if( !jdata )
        jdata = uniset::json::make_child(json, myname);

    Poco::JSON::Object::Ptr jserv = uniset::json::make_child(jdata, "LogServer");

    if( logserv )
    {
        jserv->set("host", logserv_host);
        jserv->set("port", logserv_port);
        jserv->set("state", ( logserv->isRunning() ? "RUNNIG" : "STOPPED" ));
        jserv->set("info", logserv->httpGetShortInfo());
    }

    jdata->set("io", httpDumpIO());

    auto timers = getTimersList();
    auto jtm = uniset::json::make_child(jdata, "Timers");

    jtm->set("count", timers.size());

    for( const auto& t : timers )
    {
        auto jt = uniset::json::make_child(jtm, to_string(t.id));
        jt->set("id", t.id);
        jt->set("name", getTimerName(t.id));
        jt->set("msec", t.tmr.getInterval());
        jt->set("timeleft", t.curTimeMS);
        jt->set("tick", ( t.curTick >= 0 ? t.curTick : -1 ));
    }

    auto vlist = vmon.getList();
    auto jvmon = uniset::json::make_child(jdata, "Variables");

    for( const auto& v : vlist )
        jvmon->set(v.first, v.second);


    auto jstat = uniset::json::make_child(jdata, "Statistics");
    jstat->set("processingMessageCatchCount", processingMessageCatchCount);

    auto jsens = uniset::json::make_child(jstat, "sensors");

    for( const auto& s : smStat )
    {
        std::string sname(ORepHelpers::getShortName( uniset_conf()->oind->getMapName(s.first)));
        auto js = uniset::json::make_child(jsens, sname);
        js->set("id", s.first);
        js->set("name", sname);
        js->set("count", s.second);
    }


    httpGetUserData(jdata);

    return json;
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::httpHelp( const Poco::URI::QueryParameters& params )
{
    uniset::json::help::object myhelp(myname, UniSetObject::httpGet(params));

    // 'log'
    uniset::json::help::item cmd("log", "show log level");
    myhelp.add(cmd);

    return myhelp;
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::httpRequest( const std::string& req, const Poco::URI::QueryParameters& p )
{
    if( req == "log" )
        return httpRequestLog(p);

    return UniSetObject::httpRequest(req, p);
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::httpRequestLog( const Poco::URI::QueryParameters& p )
{
    Poco::JSON::Object::Ptr jret = new Poco::JSON::Object();
    jret->set("log", Debug::str(mylog->level()));
    return jret;
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::request_conf_set( const std::string& req, const Poco::URI::QueryParameters& params )
{
    Poco::JSON::Object::Ptr jret = new Poco::JSON::Object();
    Poco::JSON::Array::Ptr jupdated = uniset::json::make_child_array(jret, "updated");

    for( const auto& p : params )
    {
        if( p.first == "sleep_msec" )
        {
            int val = uni_atoi(p.second);

            if( val > 0 )
            {
                sleep_msec = uni_atoi(p.second);
                jupdated->add(p.first);
            }

            continue;
        }

        if( p.first == "resetMsgTime" )
        {
            int val = uni_atoi(p.second);

            if( val > 0 )
            {
                resetMsgTime = uni_atoi(p.second);
                jupdated->add(p.first);
            }

            continue;
        }

        if( p.first == "forceOut" )
        {
            int val = uni_atoi(p.second);

            if( val > 0 )
            {
                forceOut = uni_atoi(p.second);
                jupdated->add(p.first);
            }

            continue;
        }


    }

    jret->set("Result", (jupdated->size() > 0 ? "OK" : "FAIL") );
    return jret;
}
#endif

// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
bool UObject_SK::activateObject()
{
    // блокирование обработки Startup
    // пока не пройдёт инициализация датчиков
    // см. preSysCommand()
    {
        activated = false;
        UniSetObject::activateObject();
        activated = true;
    }

    return true;
}
// -----------------------------------------------------------------------------
bool UObject_SK::deactivateObject()
{
    cancelled = true;
    return UniSetObject::deactivateObject();
}
// -----------------------------------------------------------------------------
void UObject_SK::preTimerInfo( const uniset::TimerMessage* _tm )
{
    timerInfo(_tm);
}
// ----------------------------------------------------------------------------
bool UObject_SK::waitSM( int wait_msec, ObjectId _testID )
{


    if( _testID == DefaultObjectId )
        _testID = smTestID;

    if( _testID == DefaultObjectId )
        return true;

    myinfo << myname << "(waitSM): waiting SM ready "
           << wait_msec << " msec"
           << " testID=" << _testID << endl;

    // waitReady можно использовать т.к. датчик это по сути IONotifyController
    if( !ui->waitReadyWithCancellation(_testID, wait_msec, cancelled) )
    {
        ostringstream err;
        err << myname
            << "(waitSM): Не дождались готовности(exist) SharedMemory к работе в течение "
            << wait_msec << " мсек";

        mycrit << err.str() << endl;
        return false;
    }

    if( !ui->waitWorking(_testID, wait_msec) )
    {
        ostringstream err;
        err << myname
            << "(waitSM): Не дождались готовности(work) SharedMemory к работе в течение "
            << wait_msec << " мсек";

        mycrit << err.str() << endl;
        return false;
    }

    return true;
}
// ----------------------------------------------------------------------------
std::string UObject_SK::help() const noexcept
{
    ostringstream s;
    s << " ************* " << myname << " HELP:" << " ************* " << endl;
    s <<  "Init default values: "  << endl;

    s << endl;

    s <<  "--"  <<  argprefix  <<  "sm-ready-timeout msec   - wait SM ready for ask sensors. Now: "  << smReadyTimeout << endl;
    s <<  "--"  <<  argprefix  <<  "sm-test-id msec sensor  - sensor for test SM ready. Now: "  << smTestID << endl;
    s <<  "--"  <<  argprefix  <<  "sleep-msec msec         - step period. Now: "  << sleep_msec << endl;

    s <<  "--"  <<  argprefix  <<  "activate-timeout msec   - activate process timeout. Now: "  << activateTimeout << endl;
    s <<  "--"  <<  argprefix  <<  "startup-timeout msec    - wait startup timeout. Now: "  << ptStartUpTimeout.getInterval() << endl;
    s <<  "--"  <<  argprefix  <<  "force-out [0|1]         - 1 - save out-values in SM at each step. Now: " << forceOut  << endl;
    s <<  "--"  <<  argprefix  <<  "heartbeat-max num       - max value for heartbeat counter. Now: " <<  maxHeartBeat << endl;
    s <<  "--"  <<  argprefix  <<  "heartbeat-time msec     - heartbeat periond. Now: " << ptHeartBeat.getInterval() << endl;
    s << endl;
    s << "--print-id-list - print ID list" << endl;
    s << endl;
    s << " ****************************************************************************************** " << endl;


    return s.str();
}
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------
void UObject_SK::callback() noexcept
{
    if( !active )
        return;

    try
    {

        // проверка таймеров
        checkTimers(this);

        if( resetMsgTime > 0 && trResetMsg.hi(ptResetMsg.checkTime()) )
        {
            //          cout << myname <<  ": ********* reset messages *********" << endl;
            resetMsg();
        }

        // обработка сообщений (таймеров и т.п.)
        for( unsigned int i = 0; i < 20; i++ )
        {
            auto m = receiveMessage();

            if( !m )
                break;

            processingMessage(m.get());

            updateOutputs(forceOut);
            //          updatePreviousValues();
        }

        // Выполнение шага программы
        step();

        // "сердцебиение"
        if( idHeartBeat != DefaultObjectId && ptHeartBeat.checkTime() )
        {
            try
            {
                ui->setValue(idHeartBeat, maxHeartBeat);
                ptHeartBeat.reset();
            }
            catch( const uniset::Exception& ex )
            {
                mycrit << myname << "(execute): " << ex << endl;
            }
        }

        // обновление выходов
        updateOutputs(forceOut);
        updatePreviousValues();
    }
    catch( const CORBA::SystemException& ex )
    {
        mycrit << myname << "(execute): СORBA::SystemException: "
               << ex.NP_minorString() << endl;
    }
    catch( const uniset::Exception& ex )
    {
        mycrit << myname << "(execute): " << ex << endl;
    }
    catch( const std::exception& ex )
    {
        mycrit << myname << "(execute): catch " << ex.what()  <<   endl;
    }

    if( !active )
        return;

    msleep( sleep_msec );
}
// -----------------------------------------------------------------------------
void UObject_SK::setValue( uniset::ObjectId _sid, long _val )
{
    if( _sid == uniset::DefaultObjectId )
        return;



    ui->setValue(_sid, _val);
}
// -----------------------------------------------------------------------------
void UObject_SK::updateOutputs( bool _force )
{

}
// -----------------------------------------------------------------------------
void UObject_SK::preSensorInfo( const uniset::SensorMessage* _sm )
{


    sensorInfo(_sm);
}
// -----------------------------------------------------------------------------
void UObject_SK::initFromSM()
{

}
// -----------------------------------------------------------------------------
void UObject_SK::askSensor( uniset::ObjectId _sid, UniversalIO::UIOCommand _cmd, uniset::ObjectId _node )
{
    ui->askRemoteSensor(_sid, _cmd, _node, getId());
}
// -----------------------------------------------------------------------------
long UObject_SK::getValue( uniset::ObjectId _sid )
{
    try
    {


        return ui->getValue(_sid);
    }
    catch( const uniset::Exception& ex )
    {
        mycrit << myname << "(getValue): " << ex << endl;
        throw;
    }
}
// -----------------------------------------------------------------------------

void UObject_SK::preAskSensors( UniversalIO::UIOCommand _cmd )
{
    PassiveTimer ptAct(activateTimeout);

    while( !activated && !ptAct.checkTime() )
    {
        cout << myname << "(preAskSensors): wait activate..." << endl;
        msleep(300);

        if( activated )
            break;
    }

    if( !activated )
        mycrit << myname
               << "(preAskSensors): ************* don`t activated?! ************" << endl;

    while( !cancelled )
    {
        try
        {

            return;
        }
        catch( const uniset::Exception& ex )
        {
            mycrit << myname << "(preAskSensors): " << ex << endl;
        }
        catch( const std::exception& ex )
        {
            mycrit << myname << "(execute): catch " << ex.what()  <<   endl;
        }

        msleep(askPause);
    }
}
// -----------------------------------------------------------------------------

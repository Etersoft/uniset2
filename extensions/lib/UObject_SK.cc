
// Метод с использованием заказа датчиков
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
/*
 DO NOT EDIT THIS FILE. IT IS AUTOGENERATED FILE.
 ALL YOUR CHANGES WILL BE LOST.
 
 НЕ РЕДАКТИРУЙТЕ ЭТОТ ФАЙЛ. ЭТОТ ФАЙЛ СОЗДАН АВТОМАТИЧЕСКИ.
 ВСЕ ВАШИ ИЗМЕНЕНИЯ БУДУТ ПОТЕРЯНЫ.
*/ 
// --------------------------------------------------------------------------
// generate timestamp: 2016-09-30+03:00
// -----------------------------------------------------------------------------
#include <memory>
#include <iomanip>
#include "Configuration.h"
#include "Exceptions.h"
#include "ORepHelpers.h"
#include "LogServer.h"
#include "DebugStream.h"
#include "LogAgregator.h"
#include "UObject_SK.h"

// -----------------------------------------------------------------------------
using namespace std;
using namespace UniSetTypes;
// -----------------------------------------------------------------------------

// --------------------------------------------------------------------------

// -----------------------------------------------------------------------------
UObject_SK::UObject_SK():
// Инициализация идентификаторов (имена берутся из конф. файла)

// Используемые идентификаторы сообщений (имена берутся из конф. файла)

// variables (public and proteced)

// ------------------
active(false),

idHeartBeat(DefaultObjectId),
maxHeartBeat(10),
confnode(0),
smReadyTimeout(0),
activated(false),
askPause(2000),
forceOut(false),
// private variables

end_private(false)
{
	mycrit << "UObject: init failed!!!!!!!!!!!!!!!" << endl;
	throw Exception( string(myname+": init failed!!!") );
}
// -----------------------------------------------------------------------------
// ( val, confval, default val )
static const std::string init3_str( const std::string& s1, const std::string& s2, const std::string& s3 )
{
	if( !s1.empty() )
		return s1;
	if( !s2.empty() )
		return s2;
	
	return s3;
}
// -----------------------------------------------------------------------------
static UniSetTypes::ObjectId init_node( xmlNode* cnode, const std::string& prop )
{
	if( prop.empty() )
		return uniset_conf()->getLocalNode();
	
	auto conf = uniset_conf();
	
	if( conf->getProp(cnode,prop).empty() )
		return conf->getLocalNode();

	return conf->getNodeID(conf->getProp(cnode,prop));
}
// -----------------------------------------------------------------------------
UObject_SK::UObject_SK( ObjectId id, xmlNode* cnode, const std::string& _argprefix ):
UniSetObject(id),
// Инициализация идентификаторов (имена берутся из конф. файла)

// Используемые идентификаторы сообщений (имена берутся из конф. файла)

// variables

sleep_msec(150),
active(true),
argprefix( (_argprefix.empty() ? myname+"-" : _argprefix) ),

idHeartBeat(DefaultObjectId),
maxHeartBeat(10),
confnode(cnode),
smReadyTimeout(0),
activated(false),
askPause(uniset_conf()->getPIntProp(cnode,"askPause",2000)),
forceOut(false),

end_private(false)
{
	auto conf = uniset_conf();
	
	
	if( UniSetTypes::findArgParam("--print-id-list",uniset_conf()->getArgc(),uniset_conf()->getArgv()) != -1 )
	{

//		abort();
	}


	if( getId() == DefaultObjectId )
	{
		ostringstream err;
		err << "(UObject::init): Unknown ObjectID!";
		throw SystemError( err.str() );
	}

    mylog = make_shared<DebugStream>();
	mylog->setLogName(myname);
	{
		ostringstream s;
		s << argprefix << "log";
		conf->initLogStream(mylog,s.str());
	}

	loga = make_shared<LogAgregator>(myname+"-loga");
	loga->add(mylog);
	loga->add(ulog());

	logserv = make_shared<LogServer>(loga);
	logserv->init( argprefix + "logserver", confnode );



	UniXML::iterator it(cnode);

	// ------- init logserver ---
	if( findArgParam("--" + argprefix + "run-logserver", conf->getArgc(), conf->getArgv()) != -1 )
	{
		logserv_host = conf->getArg2Param("--" + argprefix + "logserver-host", it.getProp("logserverHost"), "localhost");
		logserv_port = conf->getArgPInt("--" + argprefix + "logserver-port", it.getProp("logserverPort"), getId());
	}
	
	forceOut = conf->getArgPInt("--" + argprefix + "force-out",it.getProp("forceOut"),false);

	string heart = conf->getArgParam("--" + argprefix + "heartbeat-id",it.getProp("heartbeat_id"));
	if( !heart.empty() )
	{
		idHeartBeat = conf->getSensorID(heart);
		if( idHeartBeat == DefaultObjectId )
		{
			ostringstream err;
			err << myname << ": не найден идентификатор для датчика 'HeartBeat' " << heart;
			throw SystemError(err.str());
		}

		int heartbeatTime = conf->getArgPInt("--" + argprefix + "heartbeat-time",it.getProp("heartbeatTime"),conf->getHeartBeatTime());
		if( heartbeatTime>0 )
			ptHeartBeat.setTiming(heartbeatTime);
		else
			ptHeartBeat.setTiming(UniSetTimer::WaitUpTime);

		maxHeartBeat = conf->getArgPInt("--" + argprefix + "heartbeat-max",it.getProp("heartbeat_max"), 10);
	}

	// Инициализация значений
	
	
	si.id = UniSetTypes::DefaultObjectId;
	si.node = conf->getLocalNode();
	
	sleep_msec = conf->getArgPInt("--" + argprefix + "sleep-msec","150", 150);

	string s_resetTime("");
	if( s_resetTime.empty() )
		s_resetTime = "500";

	resetMsgTime = uni_atoi(init3_str(conf->getArgParam("--" + argprefix + "resetMsgTime"),conf->getProp(cnode,"resetMsgTime"),s_resetTime));
	ptResetMsg.setTiming(resetMsgTime);

	int sm_tout = conf->getArgInt("--" + argprefix + "sm-ready-timeout","");
	if( sm_tout == 0 )
		smReadyTimeout = 60000;
	else if( sm_tout < 0 )
		smReadyTimeout = UniSetTimer::WaitUpTime;
	else
		smReadyTimeout = sm_tout;

	smTestID = conf->getSensorID(init3_str(conf->getArgParam("--" + argprefix + "sm-test-id"),conf->getProp(cnode,"smTestID"),""));
	

	if( smTestID == DefaultObjectId )
		smTestID = getSMTestID();

	activateTimeout	= conf->getArgPInt("--" + argprefix + "activate-timeout", 20000);

	int msec = conf->getArgPInt("--" + argprefix + "startup-timeout", 10000);
	ptStartUpTimeout.setTiming(msec);

	// ===================== <variables> =====================
	
	// ===================== end of <variables> =====================

	vmonit(sleep_msec);
	vmonit(resetMsgTime);
	vmonit(forceOut);
	vmonit(argprefix);
	vmonit(idHeartBeat);
	vmonit(maxHeartBeat);
	vmonit(activateTimeout);
	vmonit(smReadyTimeout);
	

	// help надо выводить в конце, когда уже все переменные инициализированы по умолчанию
	if( UniSetTypes::findArgParam("--" + argprefix + "help",uniset_conf()->getArgc(),uniset_conf()->getArgv()) != -1 )
		cout << help() << endl;
}

// -----------------------------------------------------------------------------

UObject_SK::~UObject_SK()
{
}
// -----------------------------------------------------------------------------
void UObject_SK::updateValues()
{
	// Опрашиваем все входы...
	
}
// -----------------------------------------------------------------------------
void UObject_SK::updatePreviousValues() noexcept
{
	
}
// -----------------------------------------------------------------------------
void UObject_SK::checkSensors()
{
	
}
// -----------------------------------------------------------------------------
bool UObject_SK::setMsg( UniSetTypes::ObjectId _code, bool _state ) noexcept
{
	if( _code == UniSetTypes::DefaultObjectId )
	{
		mylog8 << myname << "(setMsg): попытка послать сообщение с DefaultObjectId" << endl;
		return false;	
	}

    mylog8 << myname << "(setMsg): " << ( _state ? "SEND " : "RESET " ) << endl;

    // взводим автоматический сброс
    if( _state )
    {
        ptResetMsg.reset();
        trResetMsg.hi(false);
    }

	
	
    mylog8 << myname << "(setMsg): not found MessgeOID?!!" << endl;
	return false;
}
// -----------------------------------------------------------------------------
void UObject_SK::resetMsg()
{
    mylog8 << myname << "(resetMsg): reset messages.." << endl;
// reset messages

}
// -----------------------------------------------------------------------------
UniSetTypes::ObjectId UObject_SK::getSMTestID()
{
	if( smTestID != DefaultObjectId )
		return smTestID;

	

	return DefaultObjectId;
}
// -----------------------------------------------------------------------------
void UObject_SK::testMode( bool _state )
{
	if( !_state  )
		return;

	// отключаем все выходы
	
}
// -----------------------------------------------------------------------------
std::string  UObject_SK::dumpIO()
{
	ostringstream s;
	s << myname << ": " << endl;

	std::list<std::string> v_in;
	ostringstream s1;
	
	
	std::list<std::string> v_out;
	

	s << endl;

	int n = 0;
	for( const auto& e: v_in )
	{
		s << e;
		if( (n++)%2 )
			s << std::endl;
	}
	
	s << endl;
	n = 0;
	for( const auto& e: v_out )
	{
		s << e;
		if( (n++)%2 )
			s << std::endl;
	}
	
	return std::move(s.str());
}
// ----------------------------------------------------------------------------
std::string  UObject_SK::str( UniSetTypes::ObjectId id, bool showLinkName ) const
{
	ostringstream s;
		
	return "";
}
// ----------------------------------------------------------------------------
std::string  UObject_SK::strval( UniSetTypes::ObjectId id, bool showLinkName ) const
{
	ostringstream s;
		
	return "";
}
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------
void UObject_SK::init_dlog( std::shared_ptr<DebugStream> d ) noexcept
{
	UObject_SK::mylog = d;
}
// ------------------------------------------------------------------------------------------
void UObject_SK::processingMessage( const UniSetTypes::VoidMessage* _msg )
{
	try
	{
		switch( _msg->type )
		{
			case Message::SensorInfo:
				preSensorInfo( reinterpret_cast<const SensorMessage*>(_msg) );
			break;

			case Message::Timer:
				preTimerInfo( reinterpret_cast<const TimerMessage*>(_msg) );
			break;

			case Message::SysCommand:
				preSysCommand( reinterpret_cast<const SystemMessage*>(_msg) );
			break;
                                                                                        
			default:
				break;
		}	
	}
	catch( const std::exception& ex )
	{
		mycrit  << myname << "(processingMessage): " << ex.what() << endl;
	}
}
// -----------------------------------------------------------------------------
void UObject_SK::preSysCommand( const SystemMessage* _sm )
{
	switch( _sm->command )
	{
		case SystemMessage::WatchDog:
			myinfo << myname << "(preSysCommand): WatchDog" << endl;
			if( !active || !ptStartUpTimeout.checkTime() )
			{
				mywarn << myname << "(preSysCommand): игнорируем WatchDog, потому-что только-что стартанули" << endl;
				break;
			}
		case SystemMessage::StartUp:
		{
			if( !logserv_host.empty() && logserv_port != 0 && !logserv->isRunning() )
			{
				myinfo << myname << "(preSysCommand): run log server " << logserv_host << ":" << logserv_port << endl;
				logserv->run(logserv_host, logserv_port, true);
			}

			waitSM(smReadyTimeout);
			ptStartUpTimeout.reset();
			// т.к. для io-переменных важно соблюдать последовательность!
			// сперва обновить входы..
			updateValues();
			initFromSM(); // потом обновить значения переменных, помеченных как инициализируемые из SM
			updateOutputs(true); // а потом уже выходы (принудительное обновление)
			preAskSensors(UniversalIO::UIONotify);
			askSensors(UniversalIO::UIONotify);
			active = true;
			break;
		}
		
		case SystemMessage::FoldUp:
		case SystemMessage::Finish:
			preAskSensors(UniversalIO::UIODontNotify);
			askSensors(UniversalIO::UIODontNotify);
			break;
		
		case SystemMessage::LogRotate:
		{
			// переоткрываем логи
			mylogany << myname << "(preSysCommand): logRotate" << endl;
			string fname( log()->getLogFile() );
			if( !fname.empty() )
			{
				mylog->logFile(fname.c_str(),true);
				mylogany << myname << "(preSysCommand): ***************** mylog LOG ROTATE *****************" << endl;
			}
			
			if( logserv && !logserv_host.empty() && logserv_port != 0 )
				logserv->check(true);
		}
		break;

		default:
			break;
	}
	
	sysCommand(_sm);
}
// -----------------------------------------------------------------------------

UniSetTypes::SimpleInfo* UObject_SK::getInfo( CORBA::Long userparam )
{
	UniSetTypes::SimpleInfo_var i = UniSetObject::getInfo(userparam);
	
	ostringstream inf;
	
	inf << i->info << endl;
	if( logserv /* && userparam < 0 */ )
	{
		inf << "LogServer: " << logserv_host << ":" << logserv_port 
			<< ( logserv->isRunning() ? "   [RUNNIG]" : "   [FAILED]" ) << endl;

		inf << "         " << logserv->getShortInfo() << endl;
	}
	else
		inf << "LogServer: NONE" << endl;
	
	inf << dumpIO() << endl;
	inf << endl;
	auto timers = getTimersList();
	inf << "Timers[" << timers.size() << "]:" << endl;
	for( const auto& t: timers )
	{
		inf << "  " << setw(15) << getTimerName(t.id) << "[" << t.id  << "]: msec="
			<< setw(6) << t.tmr.getInterval()
			<< "    timeleft="  << setw(6) << t.curTimeMS
			<< "    tick="  << setw(3) << ( t.curTick>=0 ? t.curTick : -1 )
			<< endl;
	}
	inf << endl;
	inf << vmon.pretty_str() << endl;
	inf << endl;
	inf << getMonitInfo() << endl;
	
	i->info =  inf.str().c_str();
	
	return i._retn();
}
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
void UObject_SK::sigterm( int signo )
{
	UniSetObject::sigterm(signo);
	active = false;
}

// -----------------------------------------------------------------------------
bool UObject_SK::activateObject()
{
	// блокирование обработки Startup 
	// пока не пройдёт инициализация датчиков
	// см. preSysCommand()
	{
		activated = false;
		UniSetObject::activateObject();
		activated = true;
	}

	return true;
}
// -----------------------------------------------------------------------------
void UObject_SK::preTimerInfo( const UniSetTypes::TimerMessage* _tm )
{
	timerInfo(_tm);
}
// ----------------------------------------------------------------------------
void UObject_SK::waitSM( int wait_msec, ObjectId _testID )
{


	if( _testID == DefaultObjectId )
		_testID = smTestID;

	if( _testID == DefaultObjectId )
		return;
		
	myinfo << myname << "(waitSM): waiting SM ready "
			<< wait_msec << " msec"
			<< " testID=" << _testID << endl;
		
	// waitReady можно использовать т.к. датчик это по сути IONotifyController
	if( !ui->waitReady(_testID,wait_msec) )
	{
		ostringstream err;
		err << myname 
			<< "(waitSM): Не дождались готовности(exist) SharedMemory к работе в течение " 
			<< wait_msec << " мсек";

        mycrit << err.str() << endl;
//		terminate();
//		abort();
		raise(SIGTERM);
		terminate();
//		throw SystemError(err.str());
	}

	if( !ui->waitWorking(_testID,wait_msec) )
	{
		ostringstream err;
		err << myname
			<< "(waitSM): Не дождались готовности(work) SharedMemory к работе в течение "
			<< wait_msec << " мсек";
	
		mycrit << err.str() << endl;
//		terminate();
//		abort();
		raise(SIGTERM);
//		throw SystemError(err.str());
	}
}
// ----------------------------------------------------------------------------
std::string UObject_SK::help() noexcept
{
	ostringstream s;
	s << " ************* " << myname << " HELP:" << " ************* " << endl;
	s <<  "Init default values: "  << endl;

	s << endl;
	
	s <<  "--"  <<  argprefix  <<  "sm-ready-timeout msec   - wait SM ready for ask sensors. Now: "  << smReadyTimeout << endl;
	s <<  "--"  <<  argprefix  <<  "sm-test-id msec sensor  - sensor for test SM ready. Now: "  << smTestID << endl;
	s <<  "--"  <<  argprefix  <<  "sleep-msec msec         - step period. Now: "  << sleep_msec << endl;
	
	s <<  "--"  <<  argprefix  <<  "activate-timeout msec   - activate process timeout. Now: "  << activateTimeout << endl;
	s <<  "--"  <<  argprefix  <<  "startup-timeout msec    - wait startup timeout. Now: "  << ptStartUpTimeout.getInterval() << endl;
    s <<  "--"  <<  argprefix  <<  "force-out [0|1]         - 1 - save out-values in SM at each step. Now: " << forceOut  << endl;
    s <<  "--"  <<  argprefix  <<  "heartbeat-max num       - max value for heartbeat counter. Now: " <<  maxHeartBeat << endl;
    s <<  "--"  <<  argprefix  <<  "heartbeat-time msec     - heartbeat periond. Now: " << ptHeartBeat.getInterval() << endl;
	s << endl;
	s << "--print-id-list - print ID list" << endl;
	s << endl;
	s << " ****************************************************************************************** " << endl;
	
	
	return std::move(s.str());
}
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------
void UObject_SK::callback() noexcept
{
	if( !active )
		return;
	try
	{

		// проверка таймеров
		checkTimers(this);

		if( resetMsgTime>0 && trResetMsg.hi(ptResetMsg.checkTime()) )
		{
//			cout << myname <<  ": ********* reset messages *********" << endl;
			resetMsg();
		}

		// обработка сообщений (таймеров и т.п.)
		for( unsigned int i=0; i<20; i++ )
		{
            auto m = receiveMessage();
            if( !m )
                break;
            processingMessage(m.get());

			updateOutputs(forceOut);
//			updatePreviousValues();
		}

		// Выполнение шага программы
		step();

		// "сердцебиение"
		if( idHeartBeat!=DefaultObjectId && ptHeartBeat.checkTime() )
		{
			try
			{
				ui->setValue(idHeartBeat,maxHeartBeat);
				ptHeartBeat.reset();
			}
			catch( const Exception& ex )
			{
				mycrit << myname << "(execute): " << ex << endl;
			}
		}

		// обновление выходов
		updateOutputs(forceOut);
		updatePreviousValues();
	}
	catch( const Exception& ex )
	{
        mycrit << myname << "(execute): " << ex << endl;
	}
	catch( const CORBA::SystemException& ex )
	{
        mycrit << myname << "(execute): СORBA::SystemException: "
                << ex.NP_minorString() << endl;
	}
    catch( const std::exception&ex )
    {
        mycrit << myname << "(execute): catch " << ex.what()  <<   endl;
    }

	if( !active )
		return;
	
	msleep( sleep_msec );
}
// -----------------------------------------------------------------------------
void UObject_SK::setValue( UniSetTypes::ObjectId _sid, long _val )
{
	if( _sid == UniSetTypes::DefaultObjectId )
		return;
		
	

	ui->setValue(_sid,_val);
}
// -----------------------------------------------------------------------------
void UObject_SK::updateOutputs( bool _force )
{
	
}
// -----------------------------------------------------------------------------
void UObject_SK::preSensorInfo( const UniSetTypes::SensorMessage* _sm )
{
	
	
	sensorInfo(_sm);
}
// -----------------------------------------------------------------------------
void UObject_SK::initFromSM()
{
	
}
// -----------------------------------------------------------------------------
void UObject_SK::askSensor( UniSetTypes::ObjectId _sid, UniversalIO::UIOCommand _cmd, UniSetTypes::ObjectId _node )
{
	ui->askRemoteSensor(_sid,_cmd,_node,getId());
}
// -----------------------------------------------------------------------------
long UObject_SK::getValue( UniSetTypes::ObjectId _sid )
{
	try
	{


		return ui->getValue(_sid);
	}
	catch( const Exception& ex )
	{
        mycrit << myname << "(getValue): " << ex << endl;
		throw;
	}
}
// -----------------------------------------------------------------------------

void UObject_SK::preAskSensors( UniversalIO::UIOCommand _cmd )
{
	PassiveTimer ptAct(activateTimeout);
	while( !activated && !ptAct.checkTime() )
	{	
		cout << myname << "(preAskSensors): wait activate..." << endl;
		msleep(300);
		if( activated )
			break;
	}
			
	if( !activated )
		mycrit << myname
			<< "(preAskSensors): ************* don`t activated?! ************" << endl;

	for( ;; )
	{
		try
		{
		
			return;
		}
		catch( const Exception& ex )
		{
            mycrit << myname << "(preAskSensors): " << ex << endl;
		}
	    catch( const std::exception&ex )
    	{
		mycrit << myname << "(execute): catch " << ex.what()  <<   endl;
	    }

		msleep(askPause);
	}
}
// -----------------------------------------------------------------------------


// Метод с использованием заказа датчиков
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
/*
 DO NOT EDIT THIS FILE. IT IS AUTOGENERATED FILE.
 ALL YOUR CHANGES WILL BE LOST.
 
 НЕ РЕДАКТИРУЙТЕ ЭТОТ ФАЙЛ. ЭТОТ ФАЙЛ СОЗДАН АВТОМАТИЧЕСКИ.
 ВСЕ ВАШИ ИЗМЕНЕНИЯ БУДУТ ПОТЕРЯНЫ.
*/ 
// --------------------------------------------------------------------------
// generate timestamp: 2025-12-13+03:00
// -----------------------------------------------------------------------------
#include <memory>
#include <iomanip>
#include "Configuration.h"
#include "Exceptions.h"
#include "ORepHelpers.h"
#include "LogServer.h"
#include "DebugStream.h"
#include "LogAgregator.h"
#include "UObject_SK.h"

// -----------------------------------------------------------------------------
using namespace std;
using namespace uniset;
// -----------------------------------------------------------------------------

// --------------------------------------------------------------------------

// -----------------------------------------------------------------------------
UObject_SK::UObject_SK():
// Инициализация идентификаторов (имена берутся из конф. файла)

// Используемые идентификаторы сообщений (имена берутся из конф. файла)

// variables (public and proteced)

// ------------------
active(false),

idHeartBeat(DefaultObjectId),
maxHeartBeat(10),
confnode(0),
smReadyTimeout(0),
activated(false),
askPause(2000),
// private variables

end_private(false)
{
	mycrit << "UObject: init failed!!!!!!!!!!!!!!!" << endl;
	throw uniset::Exception( std::string(myname+": init failed!!!") );
}
// -----------------------------------------------------------------------------
// ( val, confval, globalval, default val )
static const std::string init4_str( const std::string& s1, const std::string& s2,
				    const std::string& s3, const std::string& s4 )
{
	if( !s1.empty() )
		return s1;
	if( !s2.empty() )
		return s2;

	if( !s3.empty() )
		return s3;
	
	return s4;
}
// -----------------------------------------------------------------------------
// ( val, confval, default val )
static const std::string init3_str( const std::string& s1, const std::string& s2, const std::string& s3 )
{
	if( !s1.empty() )
		return s1;
	if( !s2.empty() )
		return s2;
	
	return s3;
}
// -----------------------------------------------------------------------------
static uniset::ObjectId init_node( xmlNode* cnode, const std::string& prop )
{
	if( prop.empty() )
		return uniset_conf()->getLocalNode();
	
	auto conf = uniset_conf();
	
	if( conf->getProp(cnode,prop).empty() )
		return conf->getLocalNode();

	return conf->getNodeID(conf->getProp(cnode,prop));
}
// -----------------------------------------------------------------------------
UObject_SK::UObject_SK( ObjectId id, xmlNode* cnode, const std::string& _argprefix, xmlNode* globalnode ):
UniSetObject(id),
// Инициализация идентификаторов (имена берутся из конф. файла)

// Используемые идентификаторы сообщений (имена берутся из конф. файла)

// variables

active(true),
argprefix( (_argprefix.empty() ? myname+"-" : _argprefix) ),

idHeartBeat(DefaultObjectId),
maxHeartBeat(10),
confnode(cnode),
smReadyTimeout(0),
activated(false),
askPause(uniset_conf()->getPIntProp(cnode,"askPause",2000)),

end_private(false)
{
	auto conf = uniset_conf();
	
	

	if( getId() == DefaultObjectId )
	{
		ostringstream err;
		err << "(UObject::init): Unknown ObjectID!";
		throw uniset::SystemError( err.str() );
	}

    mylog = make_shared<DebugStream>();
	mylog->setLogName(myname);
	{
		ostringstream s;
		s << argprefix << "log";
		conf->initLogStream(mylog,s.str());
	}

	loga = make_shared<LogAgregator>(myname+"-loga");
	loga->add(mylog);
	loga->add(ulog());

	logserv = make_shared<LogServer>(loga);
	logserv->init( argprefix + "logserver", confnode );



	UniXML::iterator it(cnode);

	// ------- init logserver ---
	if( findArgParam("--" + argprefix + "run-logserver", conf->getArgc(), conf->getArgv()) != -1 )
	{
		logserv_host = conf->getArg2Param("--" + argprefix + "logserver-host", it.getProp("logserverHost"), "localhost");
		logserv_port = conf->getArgPInt("--" + argprefix + "logserver-port", it.getProp("logserverPort"), getId());
	}
	
	string heart = conf->getArgParam("--" + argprefix + "heartbeat-id",it.getProp("heartbeat_id"));
	if( !heart.empty() )
	{
		idHeartBeat = conf->getSensorID(heart);
		if( idHeartBeat == DefaultObjectId )
		{
			ostringstream err;
			err << myname << ": не найден идентификатор для датчика 'HeartBeat' " << heart;
			throw uniset::SystemError(err.str());
		}

		int heartbeatTime = conf->getArgPInt("--" + argprefix + "heartbeat-time",it.getProp("heartbeatTime"),conf->getHeartBeatTime());
		if( heartbeatTime>0 )
			ptHeartBeat.setTiming(heartbeatTime);
		else
			ptHeartBeat.setTiming(UniSetTimer::WaitUpTime);

		maxHeartBeat = conf->getArgPInt("--" + argprefix + "heartbeat-max",it.getProp("heartbeat_max"), 10);
	}

	// Инициализация значений
	
	
	si.id = uniset::DefaultObjectId;
	si.node = conf->getLocalNode();

	int sm_tout = conf->getArgInt("--" + argprefix + "sm-ready-timeout","");
	if( sm_tout == 0 )
		smReadyTimeout = conf->getNCReadyTimeout();
	else if( sm_tout < 0 )
		smReadyTimeout = UniSetTimer::WaitUpTime;
	else
		smReadyTimeout = sm_tout;

	smTestID = conf->getSensorID(init4_str(conf->getArgParam("--" + argprefix + "sm-test-sid"),conf->getProp(cnode,"smTestSID"),conf->getProp(globalnode,"smTestSID"),""));
	

	if( smTestID == DefaultObjectId ) // -V547
		smTestID = getSMTestID();

	activateTimeout	= conf->getArgPInt("--" + argprefix + "activate-timeout", 120000);

	int msec = conf->getArgPInt("--" + argprefix + "startup-timeout", conf->getStartupIgnoreTimeout());
	ptStartUpTimeout.setTiming(msec);

	// ===================== <variables> =====================
	
	// ===================== end of <variables> =====================

	vmonit(argprefix);
	vmonit(idHeartBeat);
	vmonit(maxHeartBeat);
	vmonit(activateTimeout);
	vmonit(smReadyTimeout);
	vmonit(smTestID);
	

	// help надо выводить в конце, когда уже все переменные инициализированы по умолчанию
	if( uniset::findArgParam("--" + argprefix + "help",uniset_conf()->getArgc(),uniset_conf()->getArgv()) != -1 )
		cout << help() << endl;
}

// -----------------------------------------------------------------------------

UObject_SK::~UObject_SK()
{
}
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
uniset::ObjectId UObject_SK::getSMTestID() const
{
	if( smTestID != DefaultObjectId )
		return smTestID;

	

	return DefaultObjectId;
}
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------

#ifndef DISABLE_REST_API
Poco::JSON::Object::Ptr UObject_SK::httpDumpIO()
{
	Poco::JSON::Object::Ptr jdata = new Poco::JSON::Object();

	Poco::JSON::Object::Ptr j_in = uniset::json::make_child(jdata,"in");

	
	
	Poco::JSON::Object::Ptr j_out = uniset::json::make_child(jdata,"out");

	

	return jdata;
}
// ----------------------------------------------------------------------------
#endif

// --------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------
void UObject_SK::init_dlog( std::shared_ptr<DebugStream> d ) noexcept
{
	UObject_SK::mylog = d;
}
// ------------------------------------------------------------------------------------------
void UObject_SK::processingMessage( const uniset::VoidMessage* _msg )
{
	try
	{
		
		msgTypeStat[_msg->type] += 1;
		
		switch( _msg->type )
		{
			case Message::SensorInfo:
			{
				const SensorMessage* sm = reinterpret_cast<const SensorMessage*>(_msg);
				
				smStat[sm->id] += 1;
				
				preSensorInfo(sm);
			}
			break;

			case Message::Timer:
				preTimerInfo( reinterpret_cast<const TimerMessage*>(_msg) );
			break;

			case Message::SysCommand:
				preSysCommand( reinterpret_cast<const SystemMessage*>(_msg) );
			break;
                                                                                        
			default:
				UniSetObject::processingMessage(_msg);				
				break;
		}	
	}
	catch( const std::exception& ex )
	{
		
		processingMessageCatchCount++;
		
		mycrit  << myname << "(processingMessage): " << ex.what() << endl;
	}
}
// -----------------------------------------------------------------------------
void UObject_SK::preSysCommand( const SystemMessage* _sm )
{
	switch( _sm->command )
	{
		case SystemMessage::WatchDog:
			myinfo << myname << "(preSysCommand): WatchDog" << endl;
			if( !active || !ptStartUpTimeout.checkTime() )
			{
				mywarn << myname << "(preSysCommand): игнорируем WatchDog, потому-что только-что стартанули" << endl;
				break;
			}
		case SystemMessage::StartUp:
		{
			ostate = "StartUp...";
			try
			{
				if( !logserv_host.empty() && logserv_port != 0 && !logserv->isRunning() )
				{
					ostate = "StartUp: run log server...";
					myinfo << myname << "(preSysCommand): run log server " << logserv_host << ":" << logserv_port << endl;
					logserv->async_run(logserv_host, logserv_port);
				}
			}
			catch( std::exception& ex )
			{
				mywarn << myname << "(preSysCommand): CAN`t run log server err: " << ex.what() << endl;
			}
			catch( ... )
			{
				mywarn << myname << "(preSysCommand): CAN`t run log server err: catch ..." << endl;
			}

			ostate = "StartUp: wait sm ready..";
			if( !waitSM(smReadyTimeout) )
			{
				if( !canceled )
					uterminate();
				return;
			}

			ptStartUpTimeout.reset();

			ostate = "StartUp: pre ask sensors..";
			preAskSensors(UniversalIO::UIONotify);
			ostate = "StartUp: ask sensors..";
			askSensors(UniversalIO::UIONotify);
			active = true;
			ostate = "StartUp: [OK]";
			break;
		}
		
		case SystemMessage::FoldUp:
		case SystemMessage::Finish:
			preAskSensors(UniversalIO::UIODontNotify);
			askSensors(UniversalIO::UIODontNotify);
			break;
		
		case SystemMessage::LogRotate:
		{
			// переоткрываем логи
			mylogany << myname << "(preSysCommand): logRotate" << endl;
			string fname( log()->getLogFile() );
			if( !fname.empty() )
			{
			
				mylog->logFile(fname.c_str(),false);
			
				mylogany << myname << "(preSysCommand): ***************** mylog LOG ROTATE *****************" << endl;
			}
			
			if( logserv && !logserv_host.empty() && logserv_port != 0 )
			{
				try
				{
					mylogany << myname << "(preSysCommand): try restart logserver.." << endl;
					logserv->check(true);
				}
				catch( std::exception& ex )
				{
					mywarn << myname << "(preSysCommand): CAN`t restart log server err: " << ex.what() << endl;
				}
				catch( ... )
				{
					mywarn << myname << "(preSysCommand): CAN`t restart log server err: catch ..." << endl;
				}
			}
		}
		break;

		default:
			break;
	}
	
	sysCommand(_sm);
}
// -----------------------------------------------------------------------------

uniset::SimpleInfo* UObject_SK::getInfo( const char* userparam )
{
	uniset::SimpleInfo_var i = UniSetObject::getInfo(userparam);
	
	ostringstream inf;
	
	inf << i->info << endl;
	inf << "process state: " << ostate << endl;
	
	if( logserv /* && userparam < 0 */ )
	{
		inf << "LogServer: " << logserv_host << ":" << logserv_port 
			<< ( logserv->isRunning() ? "   [RUNNING]" : "   [STOPPED]" ) << endl;

		inf << "         " << logserv->getShortInfo() << endl;
	}
	else
		inf << "LogServer: NONE" << endl;
	
	
	
	inf << "statistics: " << endl
		<< "  processingMessageCatchCount: " << processingMessageCatchCount << endl;
	inf << "  Type of messages: " << endl;
	for( const auto& s: msgTypeStat )
		inf << "    (" << s.first << ")" << setw(10)  << getTypeOfMessage(s.first) << ": " << setw(5) << s.second << endl;
	inf << endl;
	
	auto timers = getTimersList();
	inf << "Timers[" << timers.size() << "]:" << endl;
	for( const auto& t: timers )
	{
		inf << "  " << setw(15) << getTimerName(t.id) << "[" << t.id  << "]: msec="
			<< setw(6) << t.tmr.getInterval()
			<< "    timeleft="  << setw(6) << t.curTimeMS
			<< "    tick="  << setw(3) << ( t.curTick>=0 ? t.curTick : -1 )
			<< endl;
	}
	inf << endl;
	inf << vmon.pretty_str() << endl;
	inf << endl;
	inf << getMonitInfo() << endl;
	
	i->info =  inf.str().c_str();
	
	return i._retn();
}
// -----------------------------------------------------------------------------

#ifndef DISABLE_REST_API
Poco::JSON::Object::Ptr UObject_SK::httpRequest( const uniset::UHttp::HttpRequestContext& ctx )
{
	// Обработка команды /log
	if( ctx.depth() > 0 && ctx[0] == "log" )
		return httpRequestLog(ctx.params);

	// Базовая обработка из родительского класса
	Poco::JSON::Object::Ptr json = UniSetObject::httpRequest(ctx);

	// Если запрос к корню объекта (depth==0), добавляем расширенную информацию
	if( ctx.depth() == 0 )
	{
		Poco::JSON::Object::Ptr jdata = json->getObject(myname);
		if( !jdata )
			jdata = uniset::json::make_child(json,myname);

		Poco::JSON::Object::Ptr jserv = uniset::json::make_child(jdata,"LogServer");
		if( logserv )
		{
			jserv->set("host",logserv_host);
			jserv->set("port",logserv_port);
			jserv->set("state",( logserv->isRunning() ? "RUNNING" : "STOPPED" ));
			jserv->set("info", logserv->httpGetShortInfo());
		}

		auto timers = getTimersList();
		auto jtm = uniset::json::make_child(jdata,"Timers");

		jtm->set("count",timers.size());
		for( const auto& t: timers )
		{
			auto jt = uniset::json::make_child(jtm,to_string(t.id));
			jt->set("id", t.id);
			jt->set("name", getTimerName(t.id));
			jt->set("msec", t.tmr.getInterval());
			jt->set("timeleft", t.curTimeMS);
			jt->set("tick", ( t.curTick>=0 ? t.curTick : -1 ));
		}

		auto vlist = vmon.getList();
		auto jvmon = uniset::json::make_child(jdata,"Variables");

		for( const auto& v: vlist )
			jvmon->set(v.first,v.second);

		
		auto jstat = uniset::json::make_child(jdata,"Statistics");
		jstat->set("processingMessageCatchCount", processingMessageCatchCount);

		auto jsens = uniset::json::make_child(jstat,"sensors");
		for( const auto& s: smStat )
		{
			std::string sname(uniset_conf()->oind->getShortName(s.first));
			auto js = uniset::json::make_child(jsens,sname);
			js->set("id", s.first);
			js->set("name", sname);
			js->set("count", s.second);
		}
		

		httpGetUserData(jdata);
	}

	return json;
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::httpHelp( const Poco::URI::QueryParameters& params )
{
	uniset::json::help::object myhelp(myname, UniSetObject::httpHelp(params));

	// 'log'
	uniset::json::help::item cmd("log","show log level");
	myhelp.add(cmd);

	return myhelp;
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::httpRequestLog( const Poco::URI::QueryParameters& p )
{
	Poco::JSON::Object::Ptr jret = new Poco::JSON::Object();
	jret->set("log",Debug::str(mylog->level()));
	return jret;
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::request_params_set( const std::string& req, const Poco::URI::QueryParameters& params )
{
    Poco::JSON::Object::Ptr jret = new Poco::JSON::Object();
    Poco::JSON::Array::Ptr jupdated = uniset::json::make_child_array(jret, "updated");

    for( const auto& p: params )
    {

    }

    jret->set("Result", (jupdated->size() > 0 ? "OK" : "FAIL") );
    return jret;
}
// -----------------------------------------------------------------------------
Poco::JSON::Object::Ptr UObject_SK::request_params_get( const std::string& req, const Poco::URI::QueryParameters& params )
{
    Poco::JSON::Object::Ptr jret = new Poco::JSON::Object();

    if( params.empty() )
    {

        return jret;
    }

    for( const auto& p: params )
    {

    }
    return jret;
}
#endif

// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
bool UObject_SK::activateObject()
{
	// блокирование обработки Startup 
	// пока не пройдёт инициализация датчиков
	// см. preSysCommand()
	{
		activated = false;
		UniSetObject::activateObject();
		activated = true;
	}

	return true;
}
// -----------------------------------------------------------------------------
bool UObject_SK::deactivateObject()
{
	canceled = true;
	return UniSetObject::deactivateObject();
}
// -----------------------------------------------------------------------------
void UObject_SK::preTimerInfo( const uniset::TimerMessage* _tm )
{
	timerInfo(_tm);
}
// ----------------------------------------------------------------------------
bool UObject_SK::waitSM( int wait_msec, ObjectId _testID )
{


	if( _testID == DefaultObjectId )
		_testID = smTestID;

	if( _testID == DefaultObjectId )
		return true;
		
	myinfo << myname << "(waitSM): waiting SM ready "
			<< wait_msec << " msec"
			<< " testID=" << _testID << endl;
		
	// waitReady можно использовать т.к. датчик это по сути IONotifyController
	if( !ui->waitReadyWithCancellation(_testID,wait_msec,canceled) )
	{
		ostringstream err;
		err << myname 
			<< "(waitSM): Не дождались готовности(exist) SharedMemory к работе в течение " 
			<< wait_msec << " мсек";

        mycrit << err.str() << endl;
		return false;
	}

	if( !ui->waitWorking(_testID,wait_msec) )
	{
		ostringstream err;
		err << myname
			<< "(waitSM): Не дождались готовности(work) SharedMemory к работе в течение "
			<< wait_msec << " мсек";
	
		mycrit << err.str() << endl;
		return false;
	}

	return true;
}
// ----------------------------------------------------------------------------
std::string UObject_SK::help() const noexcept
{
	ostringstream s;
	s << " ************* " << myname << " HELP:" << " ************* " << endl;
	s <<  "Init default values: "  << endl;

	s << endl;
	
	s <<  "--"  <<  argprefix  <<  "sm-ready-timeout msec   - wait SM ready for ask sensors. Now: "  << smReadyTimeout << endl;
	s <<  "--"  <<  argprefix  <<  "sm-test-id msec sensor  - sensor for test SM ready. Now: "  << smTestID << endl;

	
	s <<  "--"  <<  argprefix  <<  "activate-timeout msec   - activate process timeout. Now: "  << activateTimeout << endl;
	s <<  "--"  <<  argprefix  <<  "startup-timeout msec    - wait startup timeout. Now: "  << ptStartUpTimeout.getInterval() << endl;
    s <<  "--"  <<  argprefix  <<  "heartbeat-max num       - max value for heartbeat counter. Now: " <<  maxHeartBeat << endl;
    s <<  "--"  <<  argprefix  <<  "heartbeat-time msec     - heartbeat periond. Now: " << ptHeartBeat.getInterval() << endl;
	s << endl;

	s << " ****************************************************************************************** " << endl;
	
	
	return s.str();
}
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------

void UObject_SK::callback() noexcept
{
	if( !active )
		return;
	UniSetObject::callback();
}

// -----------------------------------------------------------------------------
void UObject_SK::setValue( uniset::ObjectId _sid, long _val )
{
	if( _sid == uniset::DefaultObjectId )
		return;
		
	

	ui->setValue(_sid,_val);
}
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
void UObject_SK::preSensorInfo( const uniset::SensorMessage* _sm )
{
	
	
	sensorInfo(_sm);
}
// -----------------------------------------------------------------------------
void UObject_SK::askSensor( uniset::ObjectId _sid, UniversalIO::UIOCommand _cmd, uniset::ObjectId _node )
{
	ui->askRemoteSensor(_sid,_cmd,_node,getId());
}
// -----------------------------------------------------------------------------
long UObject_SK::getValue( uniset::ObjectId _sid )
{
	try
	{


		return ui->getValue(_sid);
	}
	catch( const uniset::Exception& ex )
	{
        mycrit << myname << "(getValue): " << ex << endl;
		throw;
	}
}
// -----------------------------------------------------------------------------

void UObject_SK::preAskSensors( UniversalIO::UIOCommand _cmd )
{
	PassiveTimer ptAct(activateTimeout);
	while( !activated && !ptAct.checkTime() )
	{	
		cout << myname << "(preAskSensors): wait activate..." << endl;
		msleep(300);
		if( activated )
			break;
	}
			
	if( !activated )
		mycrit << myname
			<< "(preAskSensors): ************* don`t activated?! ************" << endl;

	while( !canceled )
	{
		try
		{
		
			return;
		}
		catch( const uniset::Exception& ex )
		{
            mycrit << myname << "(preAskSensors): " << ex << endl;
		}
	    catch( const std::exception&ex )
    	{
		mycrit << myname << "(execute): catch " << ex.what()  <<   endl;
	    }

		msleep(askPause);
	}
}
// -----------------------------------------------------------------------------

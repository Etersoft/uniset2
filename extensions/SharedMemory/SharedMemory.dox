/*! \page page_SharedMemory Реализация разделяемой между процессами памяти (SharedMemory)

\section sec_SM_Common Задачи решаемые объектом SharedMemory

Класс SharedMemory расширяет набор задач класса IONotifyController.
Для ознакомления с базовыми функциями см. \ref page_IONotifyController

Задачи решаемые SM:
- \ref sec_SM_Conf
- \ref sec_SM_Event
- \ref sec_SM_Depends
- \ref sec_SM_HeartBeat
- \ref sec_SM_History
- \ref sec_SM_Pulsar
- \ref sec_SM_DBLog
- \ref sec_SM_ReservSM
- \ref sec_SM_AccessControl
- \ref sec_SM_REST_API

\section sec_SM_Conf Определение списка регистрируемых датчиков
SM позволяет определять список датчиков, которые он будет предоставлять
для работы другим объектам. Помимо этого можно задавать фильтрующие поля
для списка "заказчиков"(consumer) по каждому датчику, а также
поля для фильтрования списка зависимостей(depends) по датчикам.
Все эти параметры задаются в командной строке

\par Фильтрование списка регистрируемых датчиков
\code
  --s-filter-field   - задаёт фильтрующее поле для датчиков
  --s-filter-value   - задаёт значение фильтрующего поля. Необязательный параметр.
\endcode
Пример файла настроек:
\code
  <sensors>
  ...
  <item id="12" name="Sensor12" textname="xxx" .... myfilter="m1" ...>
      <consumers>
        <item name="Consumer1" type="object" mycfilter="c1" .../>
      </consumers>
  </item>
  ...
  <item id="121" name="Sensor121" textname="xxx" .... myfilter="m1" ...>
      <consumers>
        <item name="Consumer1" type="object" mycfilter="c1" .../>
      </consumers>
  </item>
  ...
  </sensors>
\endcode
Для того, чтобы SM зарегистрировало на себя датчики 12 и 121 необходимо
указать \b --s-filter-field myfilter \b --s-filter-value m1.

\par Фильтрование заказчиков (consumer)
\code
  --с-filter-field   - задаёт фильтрующее поле для заказчиков (consumer)
  --с-filter-value   - задаёт значение фильтрующего поля. Необязательный параметр.
\endcode
Если задать \b --c-filter-field mycfilter \b --c-filter-value c1, то при загрузке
SM внесёт в список заказчиков, только те объекты, у которых будет указан параметрах
\a mycfilter="c1".

\par Фильтрование зависимостей (depends)
\code
  --d-filter-field   - задаёт фильтрующее поле для "зависимостей" (depends)
  --d-filter-value   - задаёт значение фильтрующего поля. Необязательный параметр.
\endcode

\par Фильтрование порогов (<thresholds>)
\code
  --t-filter-field   - задаёт фильтрующее поле для "порогов" (thresholds)
  --t-filter-value   - задаёт значение фильтрующего поля. Необязательный параметр.
\endcode


\note Если поле \b --X-filter-value не указано будут загружены все датчики(заказчики,зависимости)
у которых поле \b --X-filter-field не пустое.
\note Если не указывать параметры \b --X-filter-field - то в SM будут загружен ВЕСЬ список
датчиков(заказчиков, зависимостей) из секции <sensors>.


\section sec_SM_Event Уведомление о рестарте SM
В SM реализован механизм позволяющий задавать список объектов,
которым присылается уведомление о старте/рестарте SM.
Параметр определяющий фильтр, по которому формируется список объектов
задаётся из командной строки \b --e-filter.
Параметр \b --e-startup-pause msec - задаёт паузу после старта SM,
после которой заданным объектам посылается уведомление.
Чтобы указать объект которому необходимо присылать уведомление,
необходимо для него в конфигурационном файле указать поле
\b evnt_xxx="1", где \b xxx - имя заданное в качестве параметра
\b --e-filter.
Пример:
\code
  <objects>
     ...
     <item id="2342" name="MyObject" ... evnt_myfilter="1" ../>
  </objects>
\endcode
При этом в параметрах старта SM должно быть указано \b --e-filter myfilter.
Тогда при своём старте SM пришлёт объекту с идентификатором 2342 уведомление.

В качестве уведомления объектам рассылается сообщение \b SystemMessage::WatchDog.

\section sec_SM_Depends Механизм зависимостей между датчиками
В SM реализован механизм позволяющий задавать зависимости между датчиками. Т.е. датчик
будет равен "0" пока разрешающий датчик не будет равно "1". Ниже показан пример конфигурирования
зависимости.
\code
  <item id="20050" iotype="AI" name="Sensor1"" textname="Зависящий датчик 1">
     <consumers>
          <consumer name="Consumer1" type="objects"/>
     </consumers>
     <depends>
          <depend block_invert="1" name="Node_Not_Respond_FS"/>
     </depends>
  </item>
\endcode
В данном примере Sensor1 зависит от значения датчика Node_Not_Respond_FS. При этом значение блокировки
инвертировано (block_invert=1). Т.е. если Node_Not_Respond=0, то Sensor1 - будет равен своему реальному
значению. Как только Node_Not_Respond_FS станет равен 1, зависящий от него датчик Sensor1 сбросится в "0".
Описание зависимости производится в секции <depends>. Возможные поля:
\code
  block_invert - инвертировать "разрешающий" датчик
\endcode
На данный момент зависимость можно устанавливать только на дискретные датчики.


\section sec_SM_HeartBeat Слежение за "живостью" объектов ("сердцебиение")

Слежение за специальными датчиками (инкремент специальных датчиков),
а также выставление дискретных датчиков "живости" процессов.

Данный механизм построен на следующей логике:
\par
Каждому процессу, за которым необходимо следить, назначается два датчика "сердцебиения"(heartbeat),
аналоговый(счётчик) и дискретный. Во время работы, процесс периодически (время задаётся в настройках)
сохраняет в свой \b аналоговый датчик заданное значение (количество тактов).
В свою очередь процесс SM, каждый "такт"(время между шагами задаётся в настройках),
"отнимает" у этого значения 1 (декрементирует). Пока значение счётчика больше нуля, дискретный датчик
держится равным "1" (т.е. 1 - процесс "жив"). Если процесс "вылетает" и перестаёт обновлять свой счётчик,
то через некоторое количество тактов его счётчик становится меньше нуля. Как только это происходит, SM фиксирует,
"недоступность" процесса, и выставляет дискретный датчик в ноль (т.е. 0 - процесс вылетел(недоступен)).

При этом, имеется возможность для некоторых процессов (обычно для особо важных, без которых работа невозможна) указать,
время ожидания "перезапуска процесса"(heartbeat_reboot_msec) и в случае если для SM настроена работа с WDT-таймером
и за заданное время процесс не перезапустился (не обновил свой счётчик), происходит
перезагрузка контроллера (SM перестаёт сбрасывать WDT-таймер).

У аналоговых датчиков "сердцебиения" в конфигурационном файле необходимо указывать \b heartbeat="1".
А также поля:
- \b heartbeat_ds_name - имя дискретного датчика, связанного с данным аналоговым
- \b heartbeat_node="ses" - фильтрующее поле (см. --heartbeat-node)
- \b heartbeat_reboot_msec - время ожидания перезапуска процесса. Это необязательный параметр, задаётся только в случае
необходимости перезапуска контроллера.

Пример задания датчиков "сердцебиения":
- _31_04_AS - аналоговый (счётчик)
- _41_04_S - дискретный ("доступность процесса")

\code
  <item default="10" heartbeat="1" heartbeat_ds_name="_41_04_S" heartbeat_node="ses" heartbeat_reboot_msec="10000"
  id="103104" iotype="AI" name="_31_04_AS" textname="SES: IO heartbeat"/>
  <item default="1" id="104104" iotype="DI" name="_41_04_S">
     <MessagesList>
         <msg mtype="1" text="КСЭС: отключился ввод/вывод" value="0"/>
     </MessagesList>
  </item>
\endcode


\section sec_SM_History Механизм аварийного дампа
"Аварийный дамп" представляет из себя набор циклических буферов
(размер в количестве точек хранения задаётся через конф. файл),
в которых сохраняется история изменения заданного набора датчиков.
В качестве "детонатора" задаётся идентификатор датчика (если
это аналоговый датчик, то задаётся значение) при котором накопленный аварийный
дамп должен "сбрасываться". За сохранение накопленного дампа (при "сбросе")
отвечает разработчик, который может обрабатывать это событие подключившись
к сигналу SharedMemory::signal_history(). Количество циклических буферов
не ограничено, размер, а также список датчиков по которым ведётся "история"
также не ограничены.
Настройка параметров дампа осуществляется через конф. файл. Для этого
у настроечной секции объекта SharedMemory должна быть создана подсекция
"<History>".
Пример:
В данном примере задаётся две "истории".
\code
  <SharedMemory name="SharedMemory" shmID="SharedMemory">
  <History savetime="200">
  <item id="1" fuse_id="AlarmFuse1_S" fuse_invert="1" size="30" filter="a1"/>
  <item id="2" fuse_id="AlarmFuse2_AS" fuse_value="2" size="30" filter="a2"/>
  </History>
  </SharedMemory>
\endcode
где:
\code
  savetime     - задаёт дискретность сохранения точек истории, в мсек.
  id   - задаёт (внутренний) идентификатор "истории"
  fuse_id      - идентификатор датчика "детонатора"
  fuse_value   - значение срабатывания (для аналогового "детонатора")
  fuse_invert  - инвертировать (для дискретных "детонаторов"). Т.е. срабатывание на значение "0".
  size         - количество точек в хранимой истории
  filter       - поле используемое в качестве фильтра, определяющего датчики входящие в данную группу (историю).
\endcode

Каждый датчик может входить в любое количество групп (историй).

Механизм функционирует по следующей логике:

При запуске происходит считывание параметров секции <History>
и заполнение соответствующих структур хранения. При этом происходит
проход по секции <sensors> и если встречается "не пустое" поле заданное
в качестве фильтра (\b filter), датчик включается в соответствующую историю.

Далее каждые \b savetime мсек происходит запись очередной точки истории.
При этом в конец буфера добавляется новое (текущее) значение датчика,
а одно устаревшее удаляется, тем самым всегда поддерживается буфер не более
\b size точек.

Помимо этого в функциях изменения датчиков (семейство setValue) отслеживается
изменение состояния "детонаторов". Если срабатывает заданное условие для
"сброса" дампа, инициируется сигнал, в который передаётся идентификатор истории
и текущая накопленная история.

\section sec_SM_Pulsar "Мигание" специальным датчиком
В SM реализован механизм позволяющий задать специальный дискретный датчик ("пульсар"),
который будет с заданным периодом менять своё состояние. Идентификатор датчика
задаётся в настроечной секции параметром \b pulsar_id или из командной строки,
параметром \b --pulsar-id. Период мигания задаётся параметром \b pulsar_msec
или в командной строке \b --pulsar-msec. В качестве дискретного датчика можно
задать любой датчик типа DO или DI. Параметр определяющий тип заданного датчика
\b pulsar_iotype или в командной строке \b --pulsar-iotype.

\section sec_SM_DBLog Управление сохранением изменений датчиков в БД
Для оптимизации, по умолчанию в SM отключено сохранение каждого изменения датчиков в БД
(реализованное в базовом классе IONotifyController).
Параметр командной строки \b --db-logging 1 позволяет включить этот механизм
(в свою очередь работа с БД требует отдельной настройки).

\section sec_SM_ReservSM Восстановление данных из резервных SM
Для повышения надёжности работы в SharedMemory предусмотрен механизм восстановления текущего состояния (датчиков)
из списка резервных SM. После того, как SM запускается и активизируется, но до того, как она
выдаст exist()=true и с ней можно будет работать, происходит попытка получить значения всех датчиков
от резервных SM. Список резервных SM задаётся в секции <ReservList>...</ReservList>.
При этом попытки получить значения идёт в порядке указанном в списке и прекращаются, при первом успешном
доступе.
\code
  <SharedMemory ...>
  ...
  <ReservList>
    <item name="SharedMemory" node="reservnode"/>
    <item name="SharedMemory" node="reservnode2"/>
    ...
  </ReservList>
  </SharedMemory>
\endcode


\section sec_SM_AccessControl Права доступа к датчикам (ACL)

Доступ к датчикам задаётся через именованные ACL-списки в отдельной секции конфигурации и привязку ACL к датчикам по имени.

\par Уровни и приоритет разрешений
Используется битовая маска \c AccessMask со значениями:
- \b RW — чтение и запись
- \b RO — только чтение
- \b WRITE — только запись
- \b None — полный запрет
- \b Unknown — «не задано» (переход к следующему уровню)

Итоговая маска определяется по приоритету (первое совпавшее правило):
-# Персонифицированное правило в ACL для процесса  
-# \c default внутри ACL  
-# Маска по умолчанию контроллера (\c IOController::defaultAccessMask; по умолчанию RW)

\par Определение ACL в конфигурации
ACL объявляются в отдельной секции (по умолчанию \c <ACLConfig>). Каждый ACL имеет имя и необязательный атрибут \c default. Внутри перечисляются правила для процессов (\c name — имя процесса из секции <objects>, \c permission — маска доступа):

\code{.xml}
  <ACLConfig>
    <acl name="IO_RW" default="RW">
       <access name="Process1" permission="RO"/>
       <access name="Historian" permission="RO"/>
       <!-- для явно разрешённого писателя -->
       <access name="Writer1" permission="WRITE"/>
    </acl>

    <!-- Пишущий только -->
    <acl name="IO_WRITE_ONLY" default="WRITE"/>

    <!-- запрет всем -->
    <acl name="IO_DENY_ALL" default="None"/>
  </ACLConfig>
\endcode

\par Привязка ACL к датчикам
Датчик ссылается на ACL по имени через атрибут \c acl. Если атрибут не указан, используется только маска по умолчанию контроллера.

\code{.xml}
  <sensors>
     <sensor id="141" name="SensorRO"   type="DI" acl="IO_RW"/>
     <sensor id="142" name="SensorRW"   type="DI" acl="IO_RW"/>
     <sensor id="150" name="WriteOnly"  type="DO" acl="IO_WRITE_ONLY"/>
     <sensor id="160" name="ClosedAll"  type="DI" acl="IO_DENY_ALL"/>
     <!-- без acl -> действует defaultAccessMask контроллера -->
     <sensor id="170" name="DefaultOnly" type="DI"/>
  </sensors>
\endcode

\par Поведение в рантайме
При обращении к датчику для внешнего процесса проверяется \c USensorInfo::checkMask():
- если результат \c None — выбрасывается \c IOController_i::AccessDenied;
- \c RO запрещает запись, \c WRITE запрещает чтение;
- \c Unknown последовательно «проваливается» к ACL.default, затем к \c defaultAccessMask.

\note Атрибут \c readonly датчика устарел — используйте ACL. Имена процессов в ACL должны совпадать с именами в <objects>.

Возможно включение специального режима: \b --http-api-disable-access-control

Помимо этого поддерживается "горячая перезагрузка ACL"(\b reload). Это можно сделать послав процессу команду SystemMessage::ReloadConfig <br>
например при помощи утилиты 
\code
   uniset2-admin --reloadconfig ShmID
\endcode

\section sec_SM_REST_API SharedMemory HTTP API
\code
  /help    - Получение списка доступных команд
  /        - получение стандартной информации
  /get?id1,name2,id3,..&shortInfo  - получение значений указанных датчиков
       Не обязательные параметры:
       shortInfo - выдать короткую информацию о датчике (id,value,real_value и когда менялся)
  /set?supplier=Name&id1=val1&name2=val2&id3=val3&...  - выставить указанные датчики
       Не обязательные параметры:
       supplier - имя процесса меняющего датчики (из секции <objects>), для логирования.
       Параметр обязателен если включена проверка прав доступа.
       Если параметр задаётся, то обязательно должен идти первым в запросе.
  /freeze?supplier=Name&id1=val1&name2=val2&id3=val3&...  - "заморозить" изменение указанных датчиков и выставить соответствующие значения
      Не обязательные параметры:
      supplier - имя процесса меняющего датчики (из секции <objects>), для логирования.
      Параметр обязателен если включена проверка прав доступа.
      Если параметр задаётся, то обязательно должен идти первым в запросе.
  /unfreeze?supplier=Name&id1&name2&id3&...  - "разморозить" изменение указанных датчиков
      Не обязательные параметры:
      supplier - имя процесса меняющего датчики (из секции <objects>), для логирования.
      Параметр обязателен если включена проверка прав доступа.
      Если параметр задаётся, то обязательно должен идти первым в запросе.
  /sensors?offset=N&limit=M- получение полной информации по списку датчиков.
     Не обязательные параметры:
     offset - начиная с,
     limit - количество в ответе.
  /consumers?sens1,sens2,sens3     - получить список заказчиков по каждому датчику
     Не обязательные параметры:
     sens1,... - список по каким датчикам выдать ответ
  /lost    - получить список заказчиков с которыми терялась связь (и они удалялись из списка)
  /conf/get?id,name,...&props=textname,iotype,...  - Получить указанные параметры объектов (по id или name) из configure.xml.
     Если props не указаны, то отдаются все поля какие есть.
\endcode
*/

/* OBSOLETE DOC!!
 \page CommonPage Общее описание библиотеки UniSet 

  - \ref secSection1
  - \ref subIO
- Алгоритмы управления
- \ref UniSetGraphics
- \ref UniDiag

  - \ref secSection2
- \ref subTransfer
- \ref subDBSave

  - \ref secDetail    
  - \ref subObjects
- \ref subProcesses
  - \ref secResourses
  - \ref secDirStruct
  
  \section secSection1 Назначение
  Библиотека предназначена для разработки распределенных систем управления. В ней собраны основные компоненты из которых
  строятся подобные системы (базовые интерфейсы для разработки процессов управления, процессов управления вводом/выводом,
  менеджеров сообщений и т.п.). Любую систему управления можно поделить на относительно независимые объекты решающие
  следующие задачи:
  - ввод/вывод (опрос физических датчиков, обмен с другими устройствами)
- алгоритмы управления тем или иным устройств или группой устройств
- отображение информации (графический интерфейс пользователя)
- накопление и хранение информации
- просмотр накопленной информации
\par
Для каждой из задач в библиотеке разработан определенный компонент(группа компонентов). 
И разработаны универсальные механизмы взаимодействия объектов между собой.

  \section secSection2 Общие принципы работы
  Библиотека позволяет объектам системы обмениваться сообщениями, а так же непосредственно вызывать функции друг-друга. В системе объектами
управляют менеджеры. Которые позволяют управлять (через этот) менеджер сразу набором подчиненных ему объектов. Менеджер может
содержать в себе в качестве подчиненного объекта другой менеджер, что позволяет строить довольно гибкую иерархическую структуру
управления. Всё взаимодействие объектов( сетевое и межпроцессовое) строится на базе CORBA-ы.

\subsection subTransfer Взаимодействие объектов системы
     Взаимодействие объектов между собой происходит через ObjectRepository. Каждый объект становится доступным другим объектам только
после регистрации в репозитории. Для получения доступа к другому объекту (даже удаленному) необходимо знать его идентификатор(UniSetTypes::ObjectId) 
и при помощи репозитория получить на него ссылку, с которой можно работать как с указателем на объект.
    ...
    Каждый узел по возможности должен работать с максимальной автономностью. Т.е. все основные сервисы (TimerService, InfoServer, DBServer)
должны быть запущены локально. Минимизирован объем данных передаваемых между узлами системы.

\subsection subDBSave Система накопления информации
    Хранение накопленной информации реализовано на основе БД. Для этого предусмотрен специальный процесс(сервис)
называемый DBServer, обладающий специальным интерфейсом, скрывающим детали работы с конкретной БД. Основная идея состоит
в том, что данный сервис запускается на каждом узле и все процессы, которым необходимо сохранять в БД информацию работают,
с всегда доступным локальным DBServer-ом. В свою очередь этот локальный DBServer при необходимости пересылает всю 
информацию на другие узлы, на которых производится реальная запись в БД. Помимо это локальный DBServer может обеспечивать
буферизацию данных на время недоступности других узлов.
    \sa \ref secDBServer    

\subsection subIO Ввод/вывод
    Процессы ввода/вывода строятся на основе классов IOController и IONotifyController. 
      \par IOController 
        Это унифицированный интерфейс для сохранения и получения информации о состоянии дискретных и
аналоговых датчиков.
    \par IONotifyController
        Расширение IOController-а. Предоставляющее интерфейс для заказа уведомлений об изменении состояния датчиков.

\subsection UniSetGraphics Графический интерфейс пользователя
    ...
    
\subsection    UniDiag    Просмотр накопленной информации    
    Для большей универсальности слежение за работой системы, диагностирование и просмотр накопленной информации
сделаны в виде web-интерфейса написанного на PHP. \a в \a процессе \a разработки...

  \section secDetail Подробности

\subsection subObjects Объекты, Менеджеры, Активаторы
\par Объекты (UniSetObject)
    Объекты являются пассивными единицами, так как не могут функционировать без менеджера или активатора. Для того, чтобы объект 
    мог принимать сообщения и предоставлять свои функции другим объектам он должен быть зарегистрирован в менеджере объектов
    (ObjectsManager) или напрямую в активаторе (ObjectsActivator) при помощи функции ObjectsManager::addObject(...). 
\par Менеджеры (ObjectsManager)
    Менеджеры используются для управления сразу группой объектов, а также сами являются объектами и могут быть
    зарегистрированы в другом менеджере (или активаторе). Они тоже являются пассивными единицами, так как не могут функционировать без
    активатора.
\par Активаторы (ObjectsActivator)
    Активатор предназначен для активизации объектов и менеджеров. Он обладает свойствами менеджера (позволяет регистрировать в себе
    другие объекты и менеджеры) и свойствами объекта (может быть зарегистрирован в другом активаторе или менеджере). Обычно для
    запуска достаточно одного активатора.

\subsection subProcesses Процессы и потоки
    Для активизации объектов должен быть создан хотя-бы один активатор. После вызова функции ObjectsActivator::run( thread ) он
    активизирует свои подчиненные объекты. В зависимости от заданного параметра функции ObjectsActivator::run()
    он создает поток (thread=true) или захватывает ресурсы основного потока откуда вызван (thread=false) для передачи его
    ресурсов ORB (брокеру запросов). После чего все его подчиненные объекты активизируются и могут функционировать (принимать сообщения,
    предоставлять свои функции для удаленного доступа). При этом orb может создавать несколько потоков.
    \warning При уничтожении активатора, объекты (за которые он отвечает) становятся недоступными.
    \par
        Каждый объект после активизации порождает поток для обработки приходящих сообщений.  После того как сообщение помещено в очередь
    (функция UniSetObject::push() ) будится поток в котором происходит вызов UniSetObject::processingMessage() для обработки пришедшего сообщения.
    Обработка сообщения и его помещение в очередь происходят в разных потоках, это позволяет помещать новые сообщения не дожидаясь завершения
    обработки старого. На время помещения или извлечения сообщения из очереди, очередь блокируется.
    \par
        Менеджер, так как сам является объектом, может самостоятельно функционировать по своему алгоритму, принимать сообщения,
    предоставлять свои функции для удаленного доступа.             
    \par 
        Если обобщить все выше сказанное то: в программе порождается поток для каждого объекта, и один для каждого активатора 
    (поток для "распихивания" приходящих сообщений по объектам). Хотя активатор может не порождать отдельного потока, а работать
    в основном потоке программы. А также несколько потоков для orb.
        
  \section secResourses Используемые библиотеки
- libmysqlclient, libtcpwrapGK     - работа с MySQL
- linomniORB3(4) - реализация CORBA (удаленный доступ к объектам)

  
  \section secDirStruct Структура каталогов
- \b /conf - общие конфигурационные файлы библиотеки UniSet
- \b /Documents - документация к библиотеке
- \b /IDL - декларации написанные на IDL
- \b /include - h-файлы
- \b /lib - библиотека \c libUniSet.a
- \b /src - сс-файлы
- \b /Tests - отладочные и тестовые программы
- \b /Utilities - вспомогательные утилиты входящие в состав UniSet
  
*/
